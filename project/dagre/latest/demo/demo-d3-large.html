<!doctype html>

<meta charset="utf-8">
<title>Dagre Test Page</title>

<h2>Graph Visualization</h2>

<style>
body {
  font: 300 16px "Helvetica Neue";
}

svg {
  border: 1px solid #333;
}

.node rect {
  stroke-width: 1.5px;
  stroke: #333;
  fill: #fff;
}

path.edge {
  fill: none;
  stroke: #333;
  stroke-width: 1.5px;
}
</style>


<svg width=1000 height=800>
  <defs>
    <marker id="arrowhead"
            viewBox="0 0 10 10"
            refX="8"
            refY="5"
            markerUnits="strokeWidth"
            markerWidth="8"
            markerHeight="5"
            orient="auto"
            style="fill: #333">
      <path d="M 0 0 L 10 5 L 0 10 z"></path>
    </marker>
  </defs>
</svg>

<script src="http://d3js.org/d3.v2.min.js"></script>
<script src="../dagre.js"></script>

<script>
  var nodePadding = 10;

  function group(chars) {
    var groups = {};
    chars.forEach(function(c) {
      if (groups[c.group])
        groups[c.group].children.push(c);
      else
        groups[c.group] = { children: [c] };
    });
    return { children: d3.values(groups) };
  }

  function spline(points) {
    return d3.svg.line()
      .x(function(d) { return d.x; })
      .y(function(d) { return d.y; })
      .interpolate("linear")
      (points);
  }

  var svg = d3.select("svg");
  var svgGroup = svg.append("g").attr("transform", "translate(5, 5)");

  var zoom = d3.behavior.zoom()
    .scale(0.2)
    .on("zoom", function () {
      var t = d3.event.translate;
      var s = d3.event.scale;
      svgGroup.attr("transform", "translate(" + t + ") scale(" + s + ")");
  });
  svg.call(zoom);

  var colors = d3.scale.category20();

  d3.json("miserables.json", function(json) {
    console.log("|V|: ", json.nodes.length);
    console.log("|E|: ", json.links.length);

    // Get the data in the right form
    var characters = json.nodes;
    var groups = group(characters);
    var colocations = json.links;
    colocations.forEach(function(d) {
      d.source = json.nodes[d.source];
      d.target = json.nodes[d.target];
    });

    // `nodes` is center positioned for easy layout later
    var nodes = svgGroup
      .selectAll("g .node")
      .data(characters)
      .enter()
        .append("g")
        .attr("class", "node");

    var edges = svgGroup
      .selectAll("path .edge")
      .data(colocations)
      .enter()
        .append("path")
        .attr("class", "edge")
        .attr("marker-end", "url(#arrowhead)");

    // Append rectangles to the nodes. We do this before laying out the text
    // because we want the text above the rectangle.
    var rects = nodes.append("rect")
        .style("fill", function(d) { return colors(d.group); });

    // Append text
    var labels = nodes
      .append("text")
        .attr("text-anchor", "middle")
        .attr("x", 0);

    labels
      .append("tspan")
      .attr("x", 0)
      .attr("dy", "1em")
      .text(function(d) { return d.name; });

    // We need width and height for layout.
    labels.each(function(d) {
      var bbox = this.getBBox();
      d.bbox = bbox;
      d.width = bbox.width + 2 * nodePadding;
      d.height = bbox.height + 2 * nodePadding;
    });

    rects
      .attr("x", function(d) { return -(d.bbox.width / 2 + nodePadding); })
      .attr("y", function(d) { return -(d.bbox.height / 2 + nodePadding); })
      .attr("width", function(d) { return d.width; })
      .attr("height", function(d) { return d.height; });

    labels
      .attr("x", function(d) { return -d.bbox.width / 2; })
      .attr("y", function(d) { return -d.bbox.height / 2; });

    dagre.layout()
      .nodes(characters)
      .edges(colocations)
      .rankSep(100)
      .edgeSep(20)
      .debugLevel(2)
      .run();

    nodes.attr("transform", function(d) { return "translate(" + d.dagre.x + "," + d.dagre.y +")"; });

    edges.attr("d", function(e) {
      var points = e.dagre.points;
      var source = dagre.util.intersectRect(e.source.dagre, points.length > 0 ? points[0] : e.target.dagre);
      var target = dagre.util.intersectRect(e.target.dagre, points.length > 0 ? points[points.length - 1] : e.source.dagre);
      points.unshift(source);
      points.push(target);
      return spline(points);
    });
    
    svgGroup.attr("transform", "translate(5, 5) scale(0.2)");
  });
</script>
