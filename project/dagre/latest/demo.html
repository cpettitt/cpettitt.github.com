<!doctype html>

<meta charset="utf-8">
<title>Dagre Interactive Demo</title>

<style>
text {
  font: 300 16px "Helvetica Neue";
}

rect {
  fill: #fff;
}

.node > rect {
  stroke-width: 3px;
  stroke: #333;
  fill: none;
}

.edge rect {
  fill: #fff
}

.edge path {
  fill: none;
  stroke: #333;
  stroke-width: 1.5px;
}
</style>

<style>
h1, h2 {
  color: #333;
}

textarea {
  width: 800px;
}

label {
  margin-top: 1em;
  display: block;
}

.error {
  color: red;
}

svg {
  border: 1px solid #999;
}
</style>

<h1>Dagre Interactive Demo</h1>

<h2>Input</h2>

<form>
  <label for="inputGraph">Graphviz Definition</label>
  <textarea id="inputGraph" rows="5" style="display: block" onKeyUp="tryDraw();">
/* Example */
digraph {
    A [label="<div style='padding: 10px;'>A <span style='font-size:32px'>Big</span> <span style='color:red;'>HTML</span> Source!</div>"];
    C;
    E [label="A blue sink"];
    A -&gt; B -&gt; C;
    B -&gt; D -&gt; E;
    C -&gt; E;
    A -&gt; D [label="<div>A multi-rank <span style='color:blue;'>HTML</span> edge!</div>"];
}
  </textarea>

  <label for="inputStyle">CSS Styles</label>
  <textarea id="inputStyle" rows="5" style="display: block" onKeyUp="tryDraw();">
#node-E rect {
  fill: #acf;
}
  </textarea>

  <a id="graphLink">Link for this graph</a>
</form>

<h2>Graph Visualization</h2>

<svg width=800 height=600>
  <defs>
    <marker id="arrowhead"
            viewBox="0 0 10 10"
            refX="8"
            refY="5"
            markerUnits="strokeWidth"
            markerWidth="8"
            markerHeight="5"
            orient="auto"
            style="fill: #333">
      <path d="M 0 0 L 10 5 L 0 10 z"></path>
    </marker>
  </defs>
</svg>

<script src="http://d3js.org/d3.v2.min.js"></script>
<script src="dagre.js"></script>

<script>
  var inputGraph = document.querySelector("#inputGraph");

  var graphStyle = d3.select("head").append("style");
  var inputStyle = d3.select("#inputStyle");
  var graphLink = d3.select("#graphLink");

  var oldInputGraphValue;
  var oldInputStyleValue;

  var svg = d3.select("svg");
  var svgGroup = svg.append("g").attr("transform", "translate(5, 5)");

  var graphRE = /[?&]graph=([^&]+)/;
  var graphMatch = window.location.search.match(graphRE);
  if (graphMatch) {
    inputGraph.value = decodeURIComponent(graphMatch[1]);
  }
  var styleRE = /[?&]style=([^&]+)/;
  var styleMatch = window.location.search.match(styleRE);
  if (styleMatch) {
    inputStyle.text(decodeURIComponent(styleMatch[1]));
  } else if (graphMatch) {
    // If we have graph input but no style input we clear out the current
    // style. This is for backwards compatibility - we used to have only the
    // graph definition coming in via the URL.
    inputStyle.text("");
  }

  tryDraw();

  function spline(points) {
    var line = d3.svg.line()
      .x(function(d) { return d.x; })
      .y(function(d) { return d.y; })
      .interpolate("basis")
      (points);
    var curves = line.split("C");
    var last = curves.pop();
    line = curves.join("C");
    var points = last.split(",");
    line += "L" + points.slice(points.length - 2).join(",");
    return line;
  }

  function graphToURL() {
    return [window.location.protocol, '//',
            window.location.host,
            window.location.pathname,
            '?graph=', encodeURIComponent(inputGraph.value),
            '&style=', encodeURIComponent(inputStyle.node().value)].join('');
  }

  function tryDraw(force) {
    var result;

    if (oldInputGraphValue !== inputGraph.value || oldInputStyleValue !== inputStyle.node().value) {
      inputGraph.setAttribute("class", "");
      oldInputGraphValue = inputGraph.value;
      oldInputStyleValue = inputStyle.node().value;
      try {
        result = dagre.dot.toObjects(inputGraph.value);
        result.edges.forEach(function(e) { if (!e.label) { e.label = ""; } });
      } catch (e) {
        inputGraph.setAttribute("class", "error");
      }
    }

    if (result) {
      // TODO why is inputStyle.text or inputStyle.html not working here?
      graphStyle.html(inputStyle.node().value);
      graphLink.attr("href", graphToURL());

      svgGroup.selectAll().remove();

      // Get the data in the right form
      var graphNodes = result.nodes;
      var graphEdges = result.edges;

      // Clear everything out
      // TODO: support incremental updates
      svgGroup.selectAll("g").remove();

      // `nodes` is center positioned for easy layout later
      var nodes = svgGroup
        .selectAll("g .node")
        .data(graphNodes)
        .enter()
          .append("g")
            .attr("class", "node")
            .attr("id", function(d) { return "node-" + d.id; })
            .each(function(d) { d.nodePadding = 10; });

      var edges = svgGroup
        .selectAll("g .edge")
        .data(graphEdges)
        .enter()
          .append("g")
            .attr("class", "edge")
            .attr("id", function(d) { return "edge-" + d.id; })
            .each(function(d) { d.nodePadding = 0; })
            .append("path")
              .attr("marker-end", "url(#arrowhead)");

      // Append rectangles to the nodes. We do this before laying out the labels
      // because we want the text above the rectangle.
      var nodesAndEdges = svgGroup.selectAll("g .node, g .edge");

      var nodeRects = nodes.append("rect");

      // Append labels
      var labels = nodesAndEdges
        .append("g")
        .attr("class", "label")
        .classed("inline-html", function(d) { return d.label[0] === "<"; });

      var labelRects = labels.append("rect");

      var foLabels = nodesAndEdges.selectAll("g .label.inline-html")
        .append("foreignObject")
        // TODO find a better way to get the dimensions for foriegnObjects
        .attr("width", "100000");

      foLabels
        .append("xhtml:div")
        .style("float", "left")
        .html(function(d) { return d.label; })
        .each(function(d) {
          d.foWidth = this.clientWidth;
          d.foHeight = this.clientHeight;
          d.nodePadding = 0;
        });

      foLabels
        .attr("width", function(d) { return d.foWidth; })
        .attr("height", function(d) { return d.foHeight; });

      nodesAndEdges.selectAll("g .label:not(.inline-html)")
        .append("text")
          .attr("text-anchor", "left")
            .append("tspan")
            .attr("dy", "1em")
            .text(function(d) { return d.label; });

      // We need width and height for layout.
      labels.each(function(d) {
        var bbox = this.getBBox();
        d.bbox = bbox;
        if (d.label.length) {
          d.width = bbox.width + 2 * d.nodePadding;
          d.height = bbox.height + 2 * d.nodePadding;
        } else {
          d.width = d.height = 0;
        }
      });

      nodeRects
        .attr("x", function(d) { return -(d.bbox.width / 2 + d.nodePadding); })
        .attr("y", function(d) { return -(d.bbox.height / 2 + d.nodePadding); })
        .attr("width", function(d) { return d.width; })
        .attr("height", function(d) { return d.height; });

      labelRects
        .attr("x", function(d) { return -d.nodePadding; })
        .attr("y", function(d) { return -d.nodePadding; })
        .attr("width", function(d) { return d.width; })
        .attr("height", function(d) { return d.height; });

      labels
        .attr("transform", function(d) { return "translate(" + (-d.bbox.width / 2) + "," + (-d.bbox.height / 2) + ")"; });

      dagre.layout()
        .nodes(graphNodes)
        .edges(graphEdges)
        .debugLevel(1)
        .run();

      nodes.attr("transform", function(d) { return "translate(" + d.dagre.x + "," + d.dagre.y +")"; });

      edges.attr("d", function(e) {
        var points = e.dagre.points;
        var source = dagre.util.intersectRect(e.source.dagre, points.length > 0 ? points[0] : e.source.dagre);
        var target = dagre.util.intersectRect(e.target.dagre, points.length > 0 ? points[points.length - 1] : e.source.dagre);
        points.unshift(source);
        points.push(target);
        return spline(points);
      });

      svgGroup
        .selectAll(".edge g.label")
        .attr("transform", function(e) {
          var mp = e.dagre.points[Math.floor(e.dagre.points.length / 2)];
          var xDelta = -e.bbox.width / 2;
          var yDelta = -e.bbox.height / 2;
          return "translate(" + (mp.x + xDelta) + "," + (mp.y + yDelta) + ")";
        });

      // Resize the SVG element
      var svgBBox = svg.node().getBBox();
      svg.call(d3.behavior.zoom().on("zoom", function redraw() {
        svgGroup.attr("transform",
              "translate(" + d3.event.translate + ")"
              + " scale(" + d3.event.scale + ")");
      }));

      // Print metrics
    }
  }
</script>
