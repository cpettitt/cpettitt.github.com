<!DOCTYPE html>
<html lang="en">
  <head><style type="text/css">body {
  font-family: 'Helvetica Neue', Helvetica, Arial;
  font-size: 14px;
  line-height: 1.5em;
  margin: 0;
  color: #333;
}

a {
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

#sidebar {
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  width: 160px;
  border-right: 1px solid #ddd;
  background: #eee;
  margin: 0;
  padding: 20px;
  display: block;
}

#sidebar p {
  margin-top: 1em;
  margin-bottom: 0;
}

#sidebar p a {
  font-weight: bold;
}

#sidebar a {
  color: #333;
}

#sidebar ul {
  list-style: none;
  margin-top: 0;
  margin-left: 1em;
  padding-left: 1em;
  text-indent: -1em;
}

#sidebar ul li {
  line-height: 1.2em;
}

#sidebar ul li:before {
  content: "- ";
}

#content {
  overflow: auto;
  width: 600px;
  margin-left: 240px;
}

#content h1,
#content h2,
#content h3 {
  padding-top: 1em;
  padding-bottom: 0.5em;
}

#content h2,
#content h3 {
  border-bottom: 1px solid #eee;
}

#content h1 {
  font-size: 40px;
  text-align: center;
}

#content h2 {
  font-size: 32px;
}

#content h3 {
  font-size: 24px;
}

#content a {
  color: #0198e1;
}

#content code {
  font-family: Monaco, Menlo, "Courier New", monospace;
  font-size: 12px;
  margin: 0 2px;
  padding: 0 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
  background: #f5f5f5;
}

#content pre code {
  border-left: 8px solid #ddd;
  padding: 5px 10px;
  overflow: auto;
  display: block;
}
</style>
  </head>
  <body>
    <div id="sidebar">
      <p><a href="#title">Introduction</a></p>
      <p><a href="#Graph">Graph</a><ul>
<li><a href="#Graph-constructor">constructor</a></li>
<li><a href="#Graph-order">order</a></li>
<li><a href="#Graph-size">size</a></li>
<li><a href="#Graph-isDirected">isDirected</a></li>
<li><a href="#Graph-graph">graph</a></li>
<li><a href="#Graph-hasNode">hasNode</a></li>
<li><a href="#Graph-node">node</a></li>
<li><a href="#Graph-nodes">nodes</a></li>
<li><a href="#Graph-eachNode">eachNode</a></li>
<li><a href="#Graph-neighbors">neighbors</a></li>
<li><a href="#Graph-hasEdge">hasEdge</a></li>
<li><a href="#Graph-edge">edge</a></li>
<li><a href="#Graph-edges">edges</a></li>
<li><a href="#Graph-eachEdge">eachEdge</a></li>
<li><a href="#Graph-incidentNodes">incidentNodes</a></li>
<li><a href="#Graph-incidentEdges">incidentEdges</a></li>
<li><a href="#Graph-equals">equals</a></li>
<li><a href="#Graph-toString">toString</a></li>
<li><a href="#Graph-addNode">addNode</a></li>
<li><a href="#Graph-delNode">delNode</a></li>
<li><a href="#Graph-addEdge">addEdge</a></li>
<li><a href="#Graph-delEdge">delEdge</a></li>
</ul>

      </p>
      <p><a href="#Digraph">Digraph</a><ul>
<li><a href="#Digraph-constructor">constructor</a></li>
<li><a href="#Digraph-order">order</a></li>
<li><a href="#Digraph-size">size</a></li>
<li><a href="#Digraph-isDirected">isDirected</a></li>
<li><a href="#Digraph-graph">graph</a></li>
<li><a href="#Digraph-hasNode">hasNode</a></li>
<li><a href="#Digraph-node">node</a></li>
<li><a href="#Digraph-nodes">nodes</a></li>
<li><a href="#Digraph-eachNode">eachNode</a></li>
<li><a href="#Digraph-successors">successors</a></li>
<li><a href="#Digraph-predecessors">predecessors</a></li>
<li><a href="#Digraph-neighbors">neighbors</a></li>
<li><a href="#Digraph-sources">sources</a></li>
<li><a href="#Digraph-sinks">sinks</a></li>
<li><a href="#Digraph-hasEdge">hasEdge</a></li>
<li><a href="#Digraph-edge">edge</a></li>
<li><a href="#Digraph-edges">edges</a></li>
<li><a href="#Digraph-eachEdge">eachEdge</a></li>
<li><a href="#Digraph-source">source</a></li>
<li><a href="#Digraph-target">target</a></li>
<li><a href="#Digraph-incidentNodes">incidentNodes</a></li>
<li><a href="#Digraph-inEdges">inEdges</a></li>
<li><a href="#Digraph-outEdges">outEdges</a></li>
<li><a href="#Digraph-incidentEdges">incidentEdges</a></li>
<li><a href="#Digraph-equals">equals</a></li>
<li><a href="#Digraph-toString">toString</a></li>
<li><a href="#Digraph-addNode">addNode</a></li>
<li><a href="#Digraph-delNode">delNode</a></li>
<li><a href="#Digraph-addEdge">addEdge</a></li>
<li><a href="#Digraph-delEdge">delEdge</a></li>
</ul>

      </p>
      <p><a href="#alg">alg</a><ul>
<li><a href="#alg-topsort">topsort</a></li>
<li><a href="#alg-isAcyclic">isAcyclic</a></li>
<li><a href="#alg-findCycles">findCycles</a></li>
<li><a href="#alg-dijkstra">dijkstra</a></li>
<li><a href="#alg-dijkstraAll">dijkstraAll</a></li>
<li><a href="#alg-floydWarshall">floydWarshall</a></li>
<li><a href="#alg-tarjan">tarjan</a></li>
<li><a href="#alg-components">components</a></li>
<li><a href="#alg-prim">prim</a></li>
</ul>

      </p>
    </div>
    <div id="content">
      <h1 id="title">Graphlib v0.3.2</h1><p>Graphlib is a JavaScript library that provides data
structures for undirected and directed multi-graphs along with
algorithms that can be used with them.</p>
<p>This documentation describes the Graphlib API. Please visit our
<a href="https://github.com/cpettitt/graphlib">GitHub repository</a> for
more general information.</p>

      <h2 id="Graph">Graph</h2><p>The <code>Graph</code> class represents an undirected multi-graph. To use this class
use <code>require(&#39;graphlib&#39;).Graph</code>.</p>

      <h3 id="Graph-constructor">new Graph()</h3><p>Constructs a new empty <code>Graph</code>.</p>

      <h3 id="Graph-order">graph.order()</h3><p>Returns the number of nodes in the graph. For example:</p>
<pre><code class="lang-js">var graph = new Graph();
graph.addNode(1);
graph.addNode(2);

graph.order();
// =&gt; 2</code></pre>

      <h3 id="Graph-size">graph.size()</h3><p>Returns the number of edges in the graph. For example:</p>
<pre><code class="lang-js">var graph = new Graph();
graph.addNode(1);
graph.addNode(2);
graph.addEdge(null, 1, 2);

graph.size();
// =&gt; 1</code></pre>

      <h3 id="Graph-isDirected">graph.isDirected()</h3><p>Always returns <code>false</code> for <code>Graph</code> because it creates undirected graphs.</p>

      <h3 id="Graph-graph">graph.graph([value])</h3><p>The <code>graph</code> function provides a mechansim to get and set some user-defined
information on the graph object itself. With no arguments <code>graph</code> returns
the currently set value. With one argument <code>graph</code> replaces the current
value on the graph with <code>value</code>. The initial value for the graph is
<code>undefined</code>.</p>
<pre><code class="lang-js">var graph = new Graph();
graph.graph();
// =&gt; undefined

graph.graph(&quot;Some graph value&quot;);
graph.graph();
// =&gt; &quot;Some graph value&quot;</code></pre>

      <h3 id="Graph-hasNode">graph.hasNode(u)</h3><p>Returns <code>true</code> if the node with the id <code>u</code> is a member of the graph and
<code>false</code> if not.</p>

      <h3 id="Graph-node">graph.node(u, [value])</h3><p>The <code>node</code> function provides a mechanism to get and set some user-defined
information on an individual node. With one argument this function returns
the value currently assigned to the node with the id <code>u</code>. With two
arguments this function replaces the current value of the node <code>u</code> with
<code>value</code>. The initial value for nodes is <code>undefined</code>.</p>
<p>If there is no node <code>u</code> in the graph this function will throw an <code>Error</code>.</p>
<pre><code class="lang-js">var graph = new Graph();
graph.addNode(1);
graph.node(1);
// =&gt; undefined

graph.node(1, &quot;Some node value&quot;);
graph.node(1);
// =&gt; &quot;Some node value&quot;

graph.node(2);
// throws an Error</code></pre>

      <h3 id="Graph-nodes">graph.nodes()</h3><p>Returns the ids of all nodes in this graph. Use
<a href="#Graph-node"><code>graph.node(u)</code></a> to get the value for a specific node.</p>

      <h3 id="Graph-eachNode">graph.eachNode(f)</h3><p>Applies the function <code>f(id, value)</code> to each node in the graph in arbitrary
order.</p>

      <h3 id="Graph-neighbors">graph.neighbors(u)</h3><p>Returns the ids of all nodes that are adjacent to the node with the id <code>u</code>.</p>

      <h3 id="Graph-hasEdge">graph.hasEdge(e)</h3><p>Returns <code>true</code> if an edge with the id <code>e</code> exists in the graph or <code>false</code> if
not.</p>

      <h3 id="Graph-edge">graph.edge(e, [value])</h3><p>The <code>edge</code> function provides a mechanism to get and set some user-defined
information on an individual edge. With one argument this function returns
the value currently assigned to the edge with the id <code>e</code>. With two
arguments this function replaces the current value of the edge <code>e</code> with
<code>value</code>. The initial value for edges is <code>undefined</code>.</p>
<p>If there is no edge <code>e</code> in the graph this function will throw an <code>Error</code>.</p>
<pre><code class="lang-js">var graph = new Graph();
graph.addNode(1);
graph.addNode(2);
graph.edge(&quot;A&quot;, 1, 2);
// =&gt; undefined

graph.edge(&quot;A&quot;, &quot;Some edge value&quot;);
graph.edge(&quot;A&quot;);
// =&gt; &quot;Some edge value&quot;

graph.edge(&quot;B&quot;);
// throws an Error</code></pre>

      <h3 id="Graph-edges">graph.edges()</h3><p>Returns the ids of all edges in this graph. Use
<a href="#Graph-edge"><code>graph.edge(e)</code></a> to get the value for a specific edge.</p>

      <h3 id="Graph-eachEdge">graph.eachEdge(f)</h3><p>Applies the function <code>f(e, u, v, value)</code> to each edge in the graph in
arbitrary order, where <code>e</code> is the edge&#39;s id, <code>u</code> and <code>v</code> are the incident
node ids, and <code>value</code> it the value assigned to the edge. Note that the
order of <code>u</code> and <code>v</code> is not significant since this is an undirected graph.</p>

      <h3 id="Graph-incidentNodes">graph.incidentNodes(e)</h3><p>Returns the nodes that are a part of the edge <code>e</code> in a 2-element array.
There is no significance to the order in which the nodes appear in the
array.</p>

      <h3 id="Graph-incidentEdges">graph.incidentEdges(u, [v])</h3><p>Returns an arrray of ids for all edges in the graph that are incident on
the node <code>u</code>. If the node <code>u</code> is not in the graph this function raises
an <code>Error</code>.</p>
<p>Optionally the id of another node, <code>v</code>, may be be specified. This causes
the results to be filtered such that only edges between <code>u</code> and <code>v</code> are
included in the returned array. If the node <code>v</code> is specified but not a
member of the graph this function raises an <code>Error</code>.</p>

      <h3 id="Graph-equals">graph.equals(other)</h3><p>Returns <code>true</code> if <code>other</code> has the same set of nodes and edges, and the
values of those nodes and edges are equal (<code>===</code>). Returns <code>false</code>
otherwise.</p>

      <h3 id="Graph-toString">graph.toString()</h3><p>Returns a <code>String</code> representation of this graph for debugging purposes. The
format of this string is arbitrary and subject to change at any time.</p>

      <h3 id="Graph-addNode">graph.addNode(u, [value])</h3><p>Adds a new node with the id <code>u</code> to the graph. The node <code>u</code> is assigned the
value of <code>value</code> if it is specified. Otherwise it defaults to the value
<code>undefined</code>. If a node with the id <code>u</code> is already a member of the graph
this function throws an <code>Error</code>.</p>

      <h3 id="Graph-delNode">graph.delNode(u)</h3><p>Removes a node from the graph that has the id <code>u</code>. Any edges incident on
the node <code>u</code> are also removed. If the graph does not contain a node <code>u</code>
then this function will raise an <code>Error</code>.</p>

      <h3 id="Graph-addEdge">graph.addEdge([e], u, v, [value])</h3><p>Adds a new edge to the graph with the id <code>e</code> between a node with the id <code>u</code>
and a node with the id <code>v</code>. The edge <code>e</code> is assigned the value of <code>value</code>
if it is specified. Otherwise it defaults to the value <code>undefined</code>. If <code>e</code>
is <code>null</code> the graph will assign an arbitrary id to the edge. This function
will throw an <code>Error</code> if <code>u</code> or <code>v</code> are not members of this graph or if <code>e</code>
is already a member of this graph.</p>

      <h3 id="Graph-delEdge">graph.delEdge(e)</h3><p>Removes an edge in the graph with the id <code>e</code>. If no edge in the graph has
the id <code>u</code> this function will thrown an <code>Error</code>.</p>

      <h2 id="Digraph">Digraph</h2><p>The <code>Digraph</code> class represents a directed multi-digraph. To use this class
use <code>require(&#39;graphlib&#39;).Digraph</code>.</p>

      <h3 id="Digraph-constructor">new Digraph()</h3><p>Constructs a new empty <code>Digraph</code>.</p>

      <h3 id="Digraph-order">digraph.order()</h3><p>Returns the number of nodes in the digraph. For example:</p>
<pre><code class="lang-js">var graph = new Digraph();
digraph.addNode(1);
digraph.addNode(2);

digraph.order();
// =&gt; 2</code></pre>

      <h3 id="Digraph-size">digraph.size()</h3><p>Returns the number of edges in the digraph. For example:</p>
<pre><code class="lang-js">var graph = new Digraph();
digraph.addNode(1);
digraph.addNode(2);
digraph.addEdge(null, 1, 2);

digraph.size();
// =&gt; 1</code></pre>

      <h3 id="Digraph-isDirected">digraph.isDirected()</h3><p>Always returns <code>true</code> for <code>Digraph</code> because it creates directed graphs.</p>

      <h3 id="Digraph-graph">digraph.graph([value])</h3><p>The <code>graph</code> function provides a mechansim to get and set some user-defined
information on the graph object itself. With no arguments <code>graph</code> returns
the currently set value. With one argument <code>graph</code> replaces the current
value on the graph with <code>value</code>. The initial value for the graph is
<code>undefined</code>.</p>
<pre><code class="lang-js">var graph = new Digraph();
digraph.graph();
// =&gt; undefined

digraph.graph(&quot;Some graph value&quot;);
digraph.graph();
// =&gt; &quot;Some graph value&quot;</code></pre>

      <h3 id="Digraph-hasNode">digraph.hasNode(u)</h3><p>Returns <code>true</code> if the node with the id <code>u</code> is a member of the graph and
<code>false</code> if not.</p>

      <h3 id="Digraph-node">digraph.node(u, [value])</h3><p>The <code>node</code> function provides a mechanism to get and set some user-defined
information on an individual node. With one argument this function returns
the value currently assigned to the node with the id <code>u</code>. With two
arguments this function replaces the current value of the node <code>u</code> with
<code>value</code>. The initial value for nodes is <code>undefined</code>.</p>
<p>If there is no node <code>u</code> in the graph this function will throw an <code>Error</code>.</p>
<pre><code class="lang-js">var graph = new Digraph();
digraph.addNode(1);
digraph.node(1);
// =&gt; undefined

digraph.node(1, &quot;Some node value&quot;);
digraph.node(1);
// =&gt; &quot;Some node value&quot;

digraph.node(2);
// throws an Error</code></pre>

      <h3 id="Digraph-nodes">digraph.nodes()</h3><p>Returns the ids of all nodes in this digraph. Use
<a href="#Digraph-node"><code>digraph.node(u)</code></a> to get the value for a specific node.</p>

      <h3 id="Digraph-eachNode">digraph.eachNode(f)</h3><p>Applies the function <code>f(id, value)</code> to each node in the graph in arbitrary
order.</p>

      <h3 id="Digraph-successors">digraph.successors(u)</h3><p>Returns the ids of all nodes that are successors of the node with the id
<code>u</code>. If <code>u</code> is not a member of the graph this function throws an <code>Error</code>.</p>

      <h3 id="Digraph-predecessors">digraph.predecessors(u)</h3><p>Returns the ids of all nodes that are predecessors of the node with the id
<code>u</code>. If <code>u</code> is not a member of the graph this function throws an <code>Error</code>.</p>

      <h3 id="Digraph-neighbors">digraph.neighbors(u)</h3><p>Returns the ids of all nodes that are adjacent to the node with the id <code>u</code>.</p>

      <h3 id="Digraph-sources">digraph.sources()</h3><p>Returns the ids of all nodes that are in the graph that are sources. A
source in a directed graph is a node that has no in-edges.</p>

      <h3 id="Digraph-sinks">digraph.sinks()</h3><p>Returns the ids of all nodes that are in the graph that are sinks. A
sink in a directed graph is a node that has no in-edges.</p>

      <h3 id="Digraph-hasEdge">digraph.hasEdge(e)</h3><p>Returns <code>true</code> if an edge with the id <code>e</code> exists in the graph or <code>false</code> if
not.</p>

      <h3 id="Digraph-edge">digraph.edge(e, [value])</h3><p>The <code>edge</code> function provides a mechanism to get and set some user-defined
information on an individual edge. With one argument this function returns
the value currently assigned to the edge with the id <code>e</code>. With two
arguments this function replaces the current value of the edge <code>e</code> with
<code>value</code>. The initial value for edges is <code>undefined</code>.</p>
<p>If there is no edge <code>e</code> in the graph this function will throw an <code>Error</code>.</p>
<pre><code class="lang-js">var graph = new Digraph();
digraph.addNode(1);
digraph.addNode(2);
digraph.edge(&quot;A&quot;, 1, 2);
// =&gt; undefined

digraph.edge(&quot;A&quot;, &quot;Some edge value&quot;);
digraph.edge(&quot;A&quot;);
// =&gt; &quot;Some edge value&quot;

digraph.edge(&quot;B&quot;);
// throws an Error</code></pre>

      <h3 id="Digraph-edges">digraph.edges()</h3><p>Returns the ids of all edges in this digraph. Use
<a href="#Digraph-edge"><code>digraph.edge(e)</code></a> to get the value for a specific edge.</p>

      <h3 id="Digraph-eachEdge">digraph.eachEdge(f)</h3><p>Applies the function <code>f(e, source, target, value)</code> to each edge in the
graph in arbitrary order, where <code>e</code> is the edge&#39;s id, <code>source</code> is the id of
the source node, <code>target</code> is the id of the target node, and <code>value</code> it the
value assigned to the edge.</p>

      <h3 id="Digraph-source">digraph.source(e)</h3><p>Returns the source node incident on the edge with the id <code>e</code>. If no such
edge exists in the graph this function throws an <code>Error</code>.</p>

      <h3 id="Digraph-target">digraph.target(e)</h3><p>Returns the target node incident on the edge with the id <code>e</code>. If no such
edge exists in the graph this function throws an <code>Error</code>.</p>

      <h3 id="Digraph-incidentNodes">digraph.incidentNodes(e)</h3><p>Returns the nodes that are a part of the edge <code>e</code> in a 2-element array.
There is no significance to the order in which the nodes appear in the
array.</p>

      <h3 id="Digraph-inEdges">digraph.inEdges(target, [source])</h3><p>Returns an array of ids for all edges in the graph that have the node
identified by <code>target</code> as their target. If the node <code>target</code> is not in the
graph this function raises an <code>Error</code>.</p>
<p>Optionally a node identified by <code>source</code> can be specified. This causes the
results to be filtered such that only edges pointing from <code>source</code> to
<code>target</code> are included. If the node <code>source</code> is specified but is not in the
graph then this function raises an <code>Error</code>.</p>

      <h3 id="Digraph-outEdges">digraph.outEdges(source, [target])</h3><p>Returns an array of ids for all edges in the graph that have the node
identified by <code>source</code> as their source. If the node <code>source</code> is not in the
graph this function raises an <code>Error</code>.</p>
<p>Optionally a node identified by <code>target</code> can be specified. This causes the
results to be filtered such that only edges pointing from <code>source</code> to
<code>target</code> are included. If the node <code>target</code> is specified but is not in the
graph then this function raises an <code>Error</code>.</p>

      <h3 id="Digraph-incidentEdges">digraph.incidentEdges(u, [v])</h3><p>Returns an arrray of ids for all edges in the graph that are incident on
the node <code>u</code>, regardless of the direction of the edge. If the node <code>u</code> is
not in the graph this function raises an <code>Error</code>.</p>
<p>Optionally the id of another node, <code>v</code>, may be be specified. This causes
the results to be filtered such that only edges between <code>u</code> and <code>v</code> are
included in the returned array. If the node <code>v</code> is specified but not a
member of the graph this function raises an <code>Error</code>.</p>

      <h3 id="Digraph-equals">digraph.equals(other)</h3><p>Returns <code>true</code> if <code>other</code> has the same set of nodes and edges, and the
values of those nodes and edges are equal (<code>===</code>). Returns <code>false</code>
otherwise.</p>

      <h3 id="Digraph-toString">digraph.toString()</h3><p>Returns a <code>String</code> representation of this graph for debugging purposes. The
format of this string is arbitrary and subject to change at any time.</p>

      <h3 id="Digraph-addNode">digraph.addNode(u, [value])</h3><p>Adds a new node with the id <code>u</code> to the digraph. The node <code>u</code> is assigned the
value of <code>value</code> if it is specified. Otherwise it defaults to the value
<code>undefined</code>. If a node with the id <code>u</code> is already a member of the graph
this function throws an <code>Error</code>.</p>

      <h3 id="Digraph-delNode">digraph.delNode(u)</h3><p>Removes a node from the graph that has the id <code>u</code>. Any edges incident on
the node <code>u</code> are also removed. If the graph does not contain a node <code>u</code>
then this function will raise an <code>Error</code>.</p>

      <h3 id="Digraph-addEdge">digraph.addEdge([e], u, v, [value])</h3><p>Adds a new edge to the graph with the id <code>e</code> between a node with the id <code>u</code>
and a node with the id <code>v</code>. The edge <code>e</code> is assigned the value of <code>value</code>
if it is specified. Otherwise it defaults to the value <code>undefined</code>. If <code>e</code>
is <code>null</code> the graph will assign an arbitrary id to the edge. This function
will throw an <code>Error</code> if <code>u</code> or <code>v</code> are not members of this graph or if <code>e</code>
is already a member of this digraph.</p>

      <h3 id="Digraph-delEdge">digraph.delEdge(e)</h3><p>Removes an edge in the graph with the id <code>e</code>. If no edge in the graph has
the id <code>u</code> this function will thrown an <code>Error</code>.</p>

      <h2 id="alg">alg</h2><p>The <code>alg</code> modules includes a number of algorithms that can be used with the
graph classes included in graphlib. You can either get to all algorithms
using <code>var alg = require(&quot;graphlib&quot;).alg</code> or you can get a single
algorithm, e.g. <a href="#alg-topsort"><code>topsort</code></a>, using <code>var topsort =
require(&quot;graphlib&quot;).alg.topsort</code>.</p>

      <h3 id="alg-topsort">alg.topsort(g)</h3><p>An implementation of <a href="https://en.wikipedia.org/wiki/Topological_sorting">topographical
sorting</a>.</p>
<p>Given a graph <code>g</code> this function returns an array of nodes such that for
each edge <code>u -&gt; v</code>, <code>u</code> appears before <code>v</code> in the array. If the graph has a
cycle it is impossible to generate such a list and <code>CycleException</code> is
thrown.</p>

      <h3 id="isAcyclic">alg.isAyclic(g)</h3><p>Given a <a href="#Digraph"><code>Digraph</code></a>, <code>g</code>, this function returns <code>true</code> if the
graph has no cycles and returns <code>false</code> if it does. This algorithm returns
as soon as it detects the first cycle. You can use
<a href="#alg-findCycles"><code>alg.findCycles</code></a> to get the actual list of cycles in the
graph.</p>

      <h3 id="findCycles">alg.findCycles(g)</h3><p>Given a <a href="#Digraph"><code>Digraph</code></a>, <code>g</code>, this function returns all nodes that
are part of a cycle. As there may be more than one cycle in a graph this
function return an array of these cycles, where each cycle is itself
represented by an array of ids for each node involved in that cycle.
<a href="#alg-isAcyclic"><code>alg.isAcyclic</code></a> is more efficient if you only need to
determine whether a graph has a cycle or not.</p>

      <h3 id="alg-dijkstra">alg.dijkstra(g, source, [weightFunc], [incidentFunc])</h3><p>This function is an implementation of <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra&#39;s algorithm</a> which finds
the shortest path from <code>source</code> to all other nodes in <code>g</code>. This
function returns a map of <code>u -&gt; { distance, predecessor }</code>. The distance
property holds the sum of the weights from <code>source</code> to <code>u</code> along the
shortest path or <code>Number.POSITIVE_INFINITY</code> if there is no path from
<code>source</code>. The predecessor property can be used to walk the individual
elements of the path from <code>source</code> to <code>u</code> in reverse order.</p>
<p>It takes an optional <code>weightFunc(e)</code> which returns the weight of the edge
<code>e</code>. If no weightFunc is supplied then each edge is assumed to have a
weight of 1. This function throws an <code>Error</code> if any of the traversed edges
have a negative edge weight.  </p>
<p>It takes an optional <code>incidentFunc(u)</code> which returns the ids of all edges
incident to the node <code>u</code> for the purposes of shortest path traversal. By
default this function uses the <code>g.outEdges</code> for Digraphs and
<code>g.incidentEdges</code> for Graphs.</p>
<p>It takes <code>O((|E| + |V|) * log |V|)</code> time.</p>

      <h3 id="alg-dijkstraAll">alg.dijkstraAll(g, [weightFunc], [incidentFunc])</h3><p>This function finds the shortest path from each node to every other
reachable node in the graph. It is similar to
<a href="#alg-dijkstra"><code>alg.dijkstra</code></a>, but instead of returning a single-source
array, it returns a mapping of of <code>source -&gt; alg.dijksta(g, source,
weightFunc, incidentFunc)</code>.</p>
<p>This function takes an optional <code>weightFunc(e)</code> which returns the
weight of the edge <code>e</code>. If no weightFunc is supplied then each edge is
assumed to have a weight of 1. This function throws an Error if any of
the traversed edges have a negative edge weight.</p>
<p>This function takes an optional <code>incidentFunc(u)</code> which returns the ids of
all edges incident to the node <code>u</code> for the purposes of shortest path
traversal. By default this function uses the <code>outEdges</code> function on the
supplied graph.</p>
<p>This function takes <code>O(|V| * (|E| + |V|) * log |V|)</code> time.</p>

      <h3 id="floydWarshall">alg.floydWarshall(g, [weightFunc], [incidentFunc])</h3><p>This function is an implementation of the <a href="https://en.wikipedia.org/wiki/Floyd-Warshall_algorithm">Floyd-Warshall algorithm</a>,
which finds the shortest path from each node to every other reachable node
in the graph. It is similar to <a href="#alg-dijkstraAll"><code>alg.dijkstraAll</code></a>, but
it handles negative edge weights and is more efficient for some types of
graphs. This function returns a map of <code>source -&gt; { target -&gt; { distance,
predecessor }</code>. The distance property holds the sum of the weights from
<code>source</code> to <code>target</code> along the shortest path of <code>Number.POSITIVE_INFINITY</code>
if there is no path from <code>source</code>. The predecessor property can be used to
walk the individual elements of the path from <code>source</code> to <code>target</code> in
reverse order.</p>
<p>This function takes an optional <code>weightFunc(e)</code> which returns the
weight of the edge <code>e</code>. If no weightFunc is supplied then each edge is
assumed to have a weight of 1.</p>
<p>This function takes an optional <code>incidentFunc(u)</code> which returns the ids of
all edges incident to the node <code>u</code> for the purposes of shortest path
traversal. By default this function uses the <code>outEdges</code> function on the
supplied graph.</p>
<p>This algorithm takes O(|V|^3) time.</p>

      <h3 id="tarjan">alg.tarjan(g)</h3><p>This function is an implementation of <a href="http://en.wikipedia.org/wiki/Tarjan&#39;s_strongly_connected_components_algorithm">Tarjan&#39;s algorithm</a> which finds
all <a href="http://en.wikipedia.org/wiki/Strongly_connected_component">strongly connected components</a> in the directed graph <strong>g</strong>. Each
strongly connected component is composed of nodes that can reach all other
nodes in the component via directed edges. A strongly connected component
can consist of a single node if that node cannot both reach and be reached
by any other specific node in the graph. Components of more than one node
are guaranteed to have at least one cycle.</p>
<p>This function returns an array of components. Each component is itself an
array that contains the ids of all nodes in the component.</p>

      <h3 id="components">alg.components(g)</h3><p>Finds all <a href="http://en.wikipedia.org/wiki/Connected_component_(graph_theory)">connected components</a> in a graph and returns an array of these
components. Each component is itself an array that contains the ids of nodes
in the component.</p>
<p>This function only works with undirected Graphs.</p>

      <h3 id="prim">alg.prim(g, weightFunc)</h3><p><a href="https://en.wikipedia.org/wiki/Prim&#39;s_algorithm">Prim&#39;s algorithm</a> takes a connected undirected graph and generates a
<a href="https://en.wikipedia.org/wiki/Minimum_spanning_tree">minimum spanning tree</a>. This function returns the minimum spanning
tree as an undirected graph. This algorithm is derived from the description
in &quot;Introduction to Algorithms&quot;, Third Edition, Cormen, et al., Pg 634.</p>
<p>This function takes a <code>weightFunc(e)</code> which returns the weight of the edge
<code>e</code>. It throws an Error if the graph is not connected.</p>
<p>This function takes <code>O(|E| log |V|)</code> time.</p>

    </div>
  </body>
</html>
